@ 가변배열

-> 2차원 배열 선언시 마지막 열 크기를 지정하지 않고, 추후에 지정함으로써
고정된 2차원 배열 크기가 아닌 유동적인 가변 배열을 구성할 수 있음

자료형[][] 변수이름 = new 자료형[행길이][];

int [][] arr = new int[3][];

arr[0] = new int[5];
arr[1] = new int[3];
arr[2] = new int[2];


@ 메소드( Method)

-> 메소드는 타 언어에서는 함수(function) 이라고 부름
-> 우리가 기존에 작성하던 공간(main 및 기타 메소드) 도 하나의 메소드임
-> 메소드를 사용하게 됨으로써 기능별 구분을 할수 있게됨
-> 재사용하는 코드들은 메소드로 정의함으로써 불필요한 중복 코드들을 줄일수있음
-> 메소드명은 해당 기능명을 작성하는게 원칙이고, 낙타 표기법을따름

@ 메소드의 형태
public int sum(int a, int b)
{
	int c;
	c = a+b;
	return c;
}

public 반환형 메소드명(매개변수)
{
	메소드 실행코드.
	reuturn 값;
}

메소드를 작성할때 Tip
-> 순서대로 만들면 쉽게 제작이 가능하다.
1. 기본틀을 작성한다.
2. 메소드 명을 수정한다.
3. 매개변수를 수정한다.
4. 실행코드를 수정한다.
5. 리턴 데이터 타입을 수정한다.


Caller : 호출 한 메소드
Callee : 호출 당한 메소드



public int sum(int a, int b)
{
	int c;
	c = a+b;
	return c;
}

public : 접근제어 지시자 (뒤에 배우므로 지금은 무조건 메소드 생성시 public  을 쓰세요)
int : 리턴 데이터 타입(반환형태 - 반환하는 값의 데이터 타입)
sum : 메소드명 (호출시 필요한 메소드 이름)
(int a , int b ) : 매개 변수 (Parameter) 
	-> 호출시 보낸 값(인자 혹은 인수(argument))를 저장하는 변수
{ 코드;} : 해당 메소드 호출시 실행하는 코드
return c ; : 호출이 끝나면 돌아갈때 가져가는 값

	* 메소드는 리턴값이 있을경우 리턴 데이터 타입이 명확해야 함
	* 리턴값이 없는 경우에는 void 형을 사용함
	* 매개변수가 없는 경우에는 매개 변수 부분을 비워놓음 -> public int sum()


@메소드의 구분
-> 메소드는 전달인자(argument)와 반환값(return value)의 유무에 따라 4가지 유형이 있음

1. 전달인자(0), 반환값(0)
2. 전달인자(0), 반환값(X)
3. 전달인자(X), 반환값(0)
4. 전달인자(X), 반환값(X)


1. 전달인자(0),  반환값(0) 인경우 메소드

public int num(int su1, int su2)
{
	reuturn su1 + su2;
}

2. 전달인자(0), 반환값(X)인 경우 메소드

public void printValue(int a)
{
	System.out.println(a);
}

3. 전달인자(X), 반환값(0)인 경우 메소드

public int inputValue()
{
	Scanner sc = new Scanner(System.in);
	int a = sc.nextInt();
	return a;
}

4. 전달인자(X), 반환값(X)인 경우 메소드

public void onlyPrint ()
{
	System.out.println("수고하셨습니다.");
}



@메소드 메모리 처리
-> 메소드 안에서 생성되는 변수들은 해당 메소드에서만 사용이 가능함
	- 해당 메소드에서만 사용이 가능하기 때문에 이름 중복 문제가 발생하지 않음.


@메소드의 호출방식
-> 메소드를 호출할때 인수(혹은 인자)를 전달하는 방식
전달방식에 따른 2가지 방식

값에 의한 호출( Call By Value )
	-> 인수의 값을 호출한 메소드에 전달
	-> 원본 값 수정 불가

참조에 의한 호출( Call By Reference)
	-> 인수의 주소를 호출한 메소드에 전달
	-> 원본 값 수정 가능

