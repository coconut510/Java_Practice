@ Excption 이란?
-> 예외 라는 뜻을 가지고 있고, 예외는 예기치 못한 상황 이라고 볼수있음
-> 프로그래밍을 하다보면 수 많은 오류 상황을 직면 하게 됨
-> 자바에서는 예외(Exception)란 프로그램을 만든 프로그래머가 에상한
정상적인 처리에서 벗어나는 경우에 이를 처리하기 위한 방법이라고 볼수 있음
-> 예측 가능한에러를 처리하는 것을 예외 처리 라고 함

@ 예외 처리의 목적
-> 프로그램의 비정상적인 종료를 막고, 정상적인 실행상태를 유지하기 위함
	* 어떻게? : 예외 상황이 발생된 경우에 처리하는 로직을 만듦


@ try~ catch
-> 예외를 처리 하기 위한 문법
-> 자바에서는 try ~ catch 라는 문법을 통해 예측할 수 있는 부분과
에러가 발생하면 실행하는 코드로 나눌 수  가 있음
-> try는 예측을 할 수 있는 부분이고, try 에서 에러가 발생한다면 즉시 중단하고
catch  부분의 코드를 실행하게 됨
-> try 작성한 후 Ctrl + 스페이스를 눌러서 try ~ catch 구분을 사용해 보자.

	try{
	
	}
	catch (Exception e)
	{
	
	}

-> 이때 Exception e 코드는 무엇일까?
-> e 는 객체이고, Exception 은 하나의 Class 타입임
-> e 라는 객체는 예외 상황에 대한 에러 내용을 담고 있는 객체라고 보면 됨.



@ finally
-> 항상 try 와 catch  이후에만 올수있음
-> finally 는 예외 여부와 관계없이 실행되는 로직


public void start()
{
	int choice = 0;
	try
	{
		choice = sc.nextInt();
	}
	catch( Exception e)
	{
		System.out.println("숫자를 입력해주세요");
	}

}



-> finally 는 try 부분의 코드를 진행 하던, catch, 부분의 코드를 진행하던
상관없이 무조건 진행 되는 코드라고 볼수 있음

@ 그렇다면 finally 는 어떤 경우에 사용할까?
-> 흔히 Application 과 DB 를 연결해서 프로그래밍을 하게 되는데
DB 서버에 연결할때에는 가상의 스ㅡ림이라고 하는 연결통로가 생기게 됨
-> 이때 DB 사용이 끝났다면 DB와 연결되 있는 가상의 스트림을 끊어 주어야 함
	(지속적인 연결은 리소스를 계속 잡고 있기 때문에 연결 제한 및
	DB.Application 에 영향이 발생 함)
-> 하지만 실제 사용시에 정상적인 연결 후에 사용이 완료 되었을때 연결 해제 코딩을 작성해야함
-> 문제는 비정상적인 상황(예외)가 발생 했을대에는 연결이 
해제 되지 않는 문제가 발생하게됨

-> 이때 정상적인 해제를 하려면 try 구문에도 연결 해제코드를 작성해야 하고,
catch 부분에도 연결 해제 코드를 작성해야 함
-> 이때 2곳에 작성하여 코드 중복을 발생하기 보다 finally를 이용하면
try 를 진행하거나 혹은 catch 를 진행하여도 무조건 fianlly 부분의 코드를 진행하여 가상의 스트림을 끊어주게 되는 코드를 넣어두면 됨



@ try ~ with ~ resource 구문
-> 자바 7에서 추가된 기능으로 , finally 에서 작성되었던 close() 처리를 생각하고
자동으로 close 처리가 되게 하는 문자

ex)

try
{
	// 반드시 예외처리를 해야 하는 구문 작성
}
catch()
{
	// 예외가 발생하면 실행되는 구문 작성.
}
finally()
{
	// 실행 도중 해당 Exception 이 발생하거나 발생하지 않아도
	// 반드시 실행해야 하는 구문을 작성함( ex. 리소스 반납)
}


ex) try~with~resource 방식

try(자원생성코드)
{
	// 반드시 예외 처리를 해야 하는 구문 작성
}
catch()
{
	// 예외가 발생하면 실행되는 구문 작성
}


-> try~with~resource 방식을 사용하게 되면 자원 생성 코드에 대하여
try 가 알고있기 때문에 try를 정상적으로 진행 하게 되어도 자동 close 처리를 하고,
catch(예외)를 진행하게 되어도 자동으로 close처리를 하게됨.


ex) fianlly
FileReader file = null;
try
{
	file = new FileReader("test.txt");
}
catch( FileNotFoundException e)
{
	e.printStackTracer();
	return;
}
finally{
	try{
		file.close();	
	}
	catch(IOException e)
	{
		e.printStackTrace();
	}
}


ex) try~with~resource

	try(FileReader file = new FileReader("test.txt");)
	{
		
	}
	catch(FileNotFoundException e)
	{
		e.printStackTrace();
	}
	catch(IOException e)
	{
		e.printStackTrace();
	}


@ 예외의 종류 
Throwable : 예외의 가장 큰 조상, 예외 부분에서는 Object와 비슷한 최고 조상이라고 볼수 있음
	-> 실제로 우리가 구현하지는 않음
Error : 개발자가 소스코드로 해결할 수 없는 에러( 시스템 에러)
Exception : 개발자가 소스코드 해결할 수 있는 에러( 코드 에러)
Runtime Exception : 어플리케이션이 작동하면서 발생하는 에러

@ Checked Exception 과 Unchecked Exception
-> Checked Exception 은 예외처리를 강제화 해야 하는 것이고,
	Unchkecked Exception 은 예외처리를 강제화 하지 않음
-> 소스 코드 상에서 반드시 개발자가 처리해야하는 Exception을 Checked Exception 이라고 부름
-> 소스코드 상에서 개발자가 굳이 당장 처리해야 할 필요가 없는 경우에는
	Unchkecked Exception 이라고 부름

@ RunTyimeException 클래스
-> RunTimeException은 Exception의 자식이며, Unchkecked Exception임
-> 주로 프로그래머의 부주의로 인한 bug가 많기 때문에 Exception 처리 보다는 코드를 수정해야 하는 경우가 많음( 예외처리를 강제화 하지 않음)



## AtithmeticException ##

-> 0으로 나누는 연산을 할 경우에 발생

## NullPointerExcption ##
-> Null 인 레퍼런스.변수로 객체 멤버 참조 시도시 발생

## NegativeArraySizeException ##
-> 배열 크기를 음수 또는 0으로 지정한 경우 발생

## ArrayIndexOutOfBoundException ##
-> 배열의 index 범위를 넘어서 참조하는 경우 발생

## ClasscastException ##
->cast 연산자 사용시 타입 오류일때 발생.


